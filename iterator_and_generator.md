# 1) Iterable vs Iterator

**Вопрос.** Чем отличается *итерируемый объект* от *итератора*?
**Ответ.**

* **Итерируемый (iterable)** — объект, у которого есть метод `__iter__`, возвращающий новый итератор. Можно проходить много раз (`list`, `str`, `dict`).
* **Итератор (iterator)** — объект, реализующий `__iter__` и `__next__`, возвращает элементы по одному, исчерпывается.

```python
lst = [1,2,3]
it = iter(lst)
next(it)   # 1
next(it)   # 2
list(it)   # [3]
list(it)   # []  ← исчерпан
```

**Ловушка.** Один и тот же итератор пройти дважды нельзя; у итерируемого объекта новый итератор можно получить снова.

---

# 2) Протокол итерации

**Вопрос.** Как `for` работает «под капотом»?
**Ответ.**
`for x in iterable:` разворачивается в:

```python
it = iter(iterable)
while True:
    try:
        x = next(it)
    except StopIteration:
        break
```

**Ловушка.** Если забыть `StopIteration`, цикл будет бесконечным. Это часто спрашивают.

---

# 3) Одноразовость итераторов

**Вопрос.** Почему генератор или `map/filter` можно пройти только один раз?
**Ответ.** Потому что они **итераторы**: каждый вызов `next` изменяет внутреннее состояние. Повторно получить элементы нельзя без нового вызова `iter(...)`.

```python
nums = map(int, ["1","2","3"])
list(nums)   # ['1','2','3']
list(nums)   # [] ← пусто
```

---

# 4) Generator function vs обычная функция

**Вопрос.** Чем функция с `yield` отличается от обычной функции?
**Ответ.**

* Обычная функция выполняется сразу и возвращает значение.
* Генератор-функция возвращает **итератор-генератор**, выполнение приостанавливается на `yield` и возобновляется при следующем `next()`.

```python
def g():
    yield 1
    yield 2
```

**Ловушка.** Генератор создаётся сразу, но код внутри не исполняется, пока не вызовешь `next()`.

---

# 5) Generator expression vs list comprehension

**Вопрос.** Чем `(...)` отличается от `[...]`?
**Ответ.**

* `[x*x for x in range(3)]` — список, сразу в памяти.
* `(x*x for x in range(3))` — генератор, ленивый, один проход.

**Ловушка.** `sum(x*x for x in big_range)` работает без промежуточного списка, экономит память.

---

# 6) `yield` vs `yield from`

**Вопрос.** Зачем нужен `yield from`?
**Ответ.** Он «делегирует» итерацию другому генератору или итератору:

```python
def g1():
    yield from range(3)
    yield from "ab"
```

Эквивалент вложенному циклу `for x in ...: yield x`. Упрощает композицию генераторов.

---

# 7) Возврат значения из генератора

**Вопрос.** Что делает `return` внутри генератора?
**Ответ.**
Завершает генерацию и кидает `StopIteration`, где в `.value` лежит переданное значение:

```python
def g():
    yield 1
    return 42

it = g()
next(it)         # 1
next(it)         # StopIteration.value == 42
```

**Ловушка.** Это значение не видно в `for`, только при прямом `next()`.

---

# 8) Методы генератора (`send`, `throw`, `close`)

**Вопрос.** Для чего нужны методы `send`, `throw`, `close`?
**Ответ.**

* `.send(value)` — передаёт значение внутрь генератора (вместо `yield`).
* `.throw(exc)` — возбуждает исключение внутри генератора в точке `yield`.
* `.close()` — завершает генератор с `GeneratorExit`.

Это база для корутин в старом стиле.

---

# 9) itertools

**Вопрос.** Какие функции из `itertools` часто используют?
**Ответ.**

* `islice` — ленивые срезы;
* `chain` — склейка итерируемых;
* `tee` — дублирование итератора;
* `groupby` — группировка по ключу;
* `permutations`, `combinations`, `product` — комбинаторика.

**Ловушка.** `tee` копирует итератор «лениво» и держит буфер → можно легко словить OOM, если второй поток сильно отстаёт.

---

# 10) Ленивость и память

**Вопрос.** Когда генераторы предпочтительнее списков?
**Ответ.**

* При работе с большими/бесконечными потоками данных;
* При сложных пайплайнах трансформаций (`map/filter` цепочки);
* Когда важна **память**, а не многократные проходы.

---

# 11) Почему `__iter__` возвращает `self` у итератора?

**Вопрос.** Зачем в итераторе `__iter__` возвращает сам объект?
**Ответ.** Чтобы итерируемость и итерация совпадали:

```python
class MyIter:
    def __iter__(self): return self
    def __next__(self): ...
```

Это обязательное условие для корректной работы `for` и других протоколов.

---

# 12) `StopIteration` и PEP 479

**Вопрос.** Что изменилось в Python 3.5+ с `StopIteration` в генераторах?
**Ответ.**
PEP 479: если внутри генератора вызывать `raise StopIteration`, это превращается в `RuntimeError`.
Правильный способ завершить генератор — `return`.

---

# 13) Комбинация генераторов

**Вопрос.** Как написать пайплайн обработки «в стиле Unix»?
**Ответ.**

```python
def read_lines(path):
    with open(path) as f:
        for line in f: yield line.strip()

def filter_errors(lines):
    for line in lines:
        if "ERROR" in line:
            yield line

errors = filter_errors(read_lines("log.txt"))
```

**Фишка.** Такой код ленивый: строки читаются по мере запроса.

---

# 14) Async генераторы

**Вопрос.** Чем `async def ... yield` отличается от обычного генератора?
**Ответ.** Это **асинхронный генератор**: вместо `__next__` у него `__anext__`, вызывается через `async for`. Полезно при чтении сетевых потоков.

---

# 15) Практическая мини-задача

**Вопрос.** Как итерироваться по двум файлам построчно «параллельно»?
**Ответ.**

```python
with open("a.txt") as fa, open("b.txt") as fb:
    for la, lb in zip(fa, fb):
        print(la.strip(), lb.strip())
```

Если файлы разной длины → использовать `itertools.zip_longest`.

