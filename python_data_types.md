Справедливое замечание. Ниже — реально востребованные на собеседованиях вопросы по «базовым типам» с развёрнутыми ответами, примерами, типичными ловушками и “а что ещё могут докопать?”. Это то, что чаще всего отличает увереннего джуна/мидла от «знаю названия типов».

---

# 1) Идентичность vs равенство, `is` vs `==`

**Вопрос.** В чём разница между `is` и `==`? Когда `is` корректен?
**Ответ.**

* `==` сравнивает **значение** через `__eq__`.
* `is` сравнивает **идентичность объекта** (один и тот же объект в памяти).
  Использовать `is` правильно только для **синглтонов**: `None` (`x is None`), реже — `Ellipsis`, `NotImplemented`.

```python
a = [1,2]; b = [1,2]
a == b      # True
a is b      # False

x = None
x is None   # True (корректно)
```

**Ловушки.** Интернирование малых `int` и некоторых строк может «случайно» дать `is True`, но полагаться на это нельзя.

---

# 2) Хешируемость, изменяемость, ключи словаря/элементы множества

**Вопрос.** Какие объекты можно использовать как ключи в `dict` и элементы `set`?
**Ответ.** Любые **хешируемые** (immutable) объекты с корректными `__hash__` и `__eq__`: `int`, `str`, `tuple` (если внутри тоже хешируемо), `frozenset`. Нельзя: `list`, `dict`, `set`, `bytearray`.

```python
{(1,2): "ok"}          # ок, tuple хешируем
{{1,2}: "no"}          # TypeError: unhashable type: 'set'
```

**Ловушки.** `tuple` хешируем только если **все его элементы** хешируемы.
**Чего могут спросить ещё.** Как связаны `__eq__` и `__hash__` (контракт: равные объекты обязаны иметь одинаковый хеш).

---

# 3) `None` — что это и как сравнивать

**Вопрос.** Что такое `None` и как верно проверять отсутствие значения?
**Ответ.** `None` — единственный экземпляр типа `NoneType`, «нет значения». Сравнение только через `is`/`is not`.
**Ловушки.** `if x:` не эквивалентно `x is not None` (пустые коллекции дают `False`, но не равны `None`).

---

# 4) Истина/ложь объектов (truthiness)

**Вопрос.** Что считается «ложью»?
**Ответ.** `False`, `None`, `0/0.0/0j`, пустые `str`, `list`, `tuple`, `set`, `dict`, `range(0)`, `bytes/bytearray` пустые. Всё остальное — истинно.
**Ловушки.** `float('nan')` — **истина**, но `nan != nan`.

---

# 5) Числа: `int`, `float`, `decimal`, `Fraction`, `complex`

**Вопрос.** В чём разница между `int`, `float`, и когда брать `decimal`/`Fraction`?
**Ответ.**

* `int` — произвольной длины.
* `float` — двоичная плавающая точка, конечная точность: `0.1 + 0.2 != 0.3`.
* `decimal.Decimal` — десятичная арифметика с регулируемой точностью (финансы).
* `fractions.Fraction` — точные рациональные числа (мат. задачи).
* `complex` — комплексные с `j`.

```python
from decimal import Decimal
Decimal('0.1') + Decimal('0.2') == Decimal('0.3')  # True
```

**Ловушки.** Сравнение `float` лучше делать с допуском: `math.isclose(a, b)`.

---

# 6) `bool` — подкласс `int`

**Вопрос.** Почему `True == 1`, но `True is 1` — `False`?
**Ответ.** `bool` наследуется от `int`, значения 1/0, но это **другие объекты**.
**Ловушки.** `sum([True, True, False]) == 2` — иногда это полезно, иногда мешает.

---

# 7) Строки, Юникод, байты

**Вопрос.** Чем `str` отличается от `bytes`/`bytearray`? Когда нужны кодеки?
**Ответ.**

* `str` — последовательность Юникод-символов (immutable).
* `bytes` — последовательность 0..255 (immutable), `bytearray` — mutable.
* Для преобразования нужен кодек (`utf-8` чаще всего):

```python
b = "Привет".encode("utf-8")     # bytes
s = b.decode("utf-8")            # str
```

**Ловушки.** Ошибки `UnicodeEncodeError`/`UnicodeDecodeError` при неверном кодеке; смешивание `str` и `bytes` в операциях — `TypeError`.

---

# 8) Списки: копирование и «мелкое/глубокое»

**Вопрос.** Как корректно скопировать список? Чем `copy` отличается от `deepcopy`?
**Ответ.**

* Поверхностная копия: `lst.copy()`, `list(lst)`, `lst[:]` — копирует контейнер, **но не вложенные объекты**.
* Глубокая: `copy.deepcopy(lst)` — рекурсивная копия.

```python
import copy
a = [[1],[2]]
b = a.copy()
b[0].append(99)
a  # [[1, 99], [2]]  ← вложенность общая
c = copy.deepcopy(a)
```

**Ловушки.** Часто на собесах: «почему меняется оригинал после копии?»

---

# 9) Кортежи: неизменяемые, но не обязательно «глубоко»

**Вопрос.** Чем `tuple` полезен помимо «нельзя менять»?
**Ответ.**

* Лёгкий и компактный контейнер; может быть ключом словаря, если внутри всё хешируемо.
* Удобен для «запаковки» фиксированных структур, возврат нескольких значений.
  **Ловушки.** `tuple` неизменяем, но если внутри список — список можно менять.

---

# 10) `range` — ленивый диапазон

**Вопрос.** Что такое `range` и когда он материализуется?
**Ответ.** Ленивая, иммутабельная последовательность, хранит только `start`, `stop`, `step`, поддерживает `len`, индексирование, `in`. Не строит список чисел.
**Ловушки.** `list(range(...))` материализует — по памяти/времени может быть дорого.

---

# 11) Множества (`set`/`frozenset`): операции и сложность

**Вопрос.** Что важно знать о множествах?
**Ответ.**

* Уникальные элементы, нет порядка (хотя порядок вывода может казаться стабильным между прогонами — нельзя полагаться).
* Операции: `|` (объединение), `&` (пересечение), `-` (разность), `^` (симметрическая разность).
* Амортизированно `O(1)` для `in`/`add`/`remove`.
* `frozenset` — неизменяемый, хешируемый.

```python
a = {1,2,3}; b = {3,4}
a & b   # {3}
a | b   # {1,2,3,4}
```

**Ловушки.** Нельзя хранить внутри не-хешируемые объекты.

---

# 12) Словари: порядок, view-объекты, `fromkeys`, «глубина» ключей

**Вопрос.** Как устроен `dict` сегодня?
**Ответ.**

* С Python 3.7+ порядок **вставки** ключей сохраняется.
* `keys()`, `values()`, `items()` возвращают «живые» view-объекты (отражают изменения).
* `dict.fromkeys(iterable, value=None)` создаёт словарь с ключами из итерируемого и единым значением:

```python
d = dict.fromkeys(['a','b','c'], 0)  # {'a':0, 'b':0, 'c':0}
```

**Ловушки.** `fromkeys(..., mutable_value)` — один и тот же объект на всех ключах:

```python
d = dict.fromkeys('ab', [])
d['a'].append(1)
d  # {'a':[1], 'b':[1]}  ← один список!
```

**Чего могут спросить ещё.** Амортизированная сложность доступа — `O(1)`, коллизии и их влияние, почему порядок теперь стабильный (слот + список ключей).

---

# 13) Срезы (slicing): копия vs view

**Вопрос.** Срезы коллекций — это копия или представление?
**Ответ.**

* Для `list/tuple/str/bytes/bytearray` — **новый объект** (копия диапазона).
* Для `memoryview`, `numpy` — часто «вид» без копирования (но это уже не базовое ядро Python).
  **Ловушки.** `lst[:]` — поверхностная копия списка.

---

# 14) Итерабельный vs Итератор

**Вопрос.** Чем «итерабельный» (iterable) отличается от «итератора» (iterator)?
**Ответ.**

* Iterable реализует `__iter__` и возвращает **итератор**.
* Iterator реализует `__iter__` и `__next__` и «исчерпывается».
  **Ловушки.** Повторный проход по одному и тому же итератору ничего не даст (нужно заново получить через `iter(iterable)`).

---

# 15) Сравнение разных типов и «богатые» сравнения

**Вопрос.** Можно ли сравнить объекты разных типов?
**Ответ.** В Python 3 произвольные сравнения разных типов запрещены (`TypeError`), кроме случаев, когда типы сами определяют поведение (`__lt__/__gt__` и т.д.). Равенство (`==`) между разными типами обычно `False` (кроме `bool` и `int`).

---

# 16) Частые ошибки с изменяемыми аргументами по умолчанию

**Вопрос.** Почему так делать плохо?

```python
def f(x, acc=[]):
    acc.append(x)
    return acc
```

**Ответ.** Значение по умолчанию вычисляется **один раз** при определении функции — все вызовы делят один список. Решение:

```python
def f(x, acc=None):
    if acc is None:
        acc = []
    acc.append(x)
    return acc
```

---

# 17) Иммутабельность строк и конкатенация

**Вопрос.** Почему часто советуют использовать `''.join(...)`?
**Ответ.** `str` неизменяемы: `s += piece` постоянно создаёт новые объекты. Сбор через список и `''.join` — эффективнее по времени и памяти при многих склейках.

---

# 18) Производительность и сложность коллекций

**Вопрос.** Какова амортизированная сложность ключевых операций?
**Ответ (упрощённо).**

* `list`: индексирование `O(1)`, вставка/удаление в конец `амортиз. O(1)`, в середину `O(n)`, `in` — `O(n)`.
* `dict`/`set`: `in`/доступ/вставка/удаление — амортиз. `O(1)`.
* `tuple`/`str`: как списки, но неизменяемые.

---

# 19) `bytes` vs `bytearray`

**Вопрос.** Когда использовать `bytearray`?
**Ответ.** Когда нужна **изменяемая** последовательность байтов (например, собирать бинарный буфер, модифицировать кусочки файла). `bytes` — immutable и подходит для ключей/словарей, если нужно.

---

# 20) Интернирование (`str`, малые `int`)

**Вопрос.** Почему иногда `a is b` для одинаковых маленьких чисел/литералов строк — True?
**Ответ.** Интерпретатор может кешировать малые `int` и интернировать строки для оптимизации. Это **не контракт**, поведение — детализация реализации. В коде полагаться нельзя.

---

# 21) Что такое «базовые последовательности» и «последовательностный протокол»

**Вопрос.** Что делает объект «последовательностью»?
**Ответ.** Поддержка `__len__`, `__getitem__` с индексами от 0, опционально `__contains__`, срезы. Многие операции будут «работать» даже без наследования от конкретных ABC.

---

# 22) Частая «мини-задача»: уникализация и порядок

**Вопрос.** Как получить уникальные элементы **с сохранением порядка**?
**Ответ.**

* Python 3.7+: `dict` сохраняет порядок — можно так:

```python
lst = ["a","b","a","c","b"]
unique = list(dict.fromkeys(lst))      # ['a','b','c']
```

* Или `OrderedDict` (до 3.7) / или `set` + ручная фильтрация с проверкой.

---

# 23) Что делает `dict.fromkeys` и где подвох?

**Вопрос.** Объясни `dict.fromkeys`.
**Ответ.** Создаёт словарь из итерируемого ключей и одного значения по умолчанию.

```python
d = dict.fromkeys("abc", 0)  # {'a':0,'b':0,'c':0}
```

**Подвох.** Если дать **изменяемое** значение — одно и то же значение разделят все ключи (см. пункт 12).

---

# 24) Почему `tuple` меньше по памяти, чем `list`?

**Вопрос.** Причина?
**Ответ.** У `tuple` фиксированный размер, нет механизмов роста/удаления, структура хранящая capacity не нужна, поэтому накладные расходы ниже. Это отражается и на скорости хеширования/сравнения.

---

# 25) «Неизменяемый контейнер с изменяемым содержимым»

**Вопрос.** Может ли «неизменяемый» объект «меняться»?
**Ответ.** Сам — нет, но если внутри лежит изменяемый объект, его состояние можно поменять:

```python
t = ([],)
t[0].append(1)
t  # ( [1], )  ← сам tuple не менялся, менялся список внутри
```

**Ловушки.** Поэтому такой `tuple` **не** хешируем.

---

## Мини-шпаргалка «о чём ещё могут спросить коротко»

* Почему `len(some_object)` вызывает `some_object.__len__()` и должен возвращать `int ≥ 0`.
* Отличия `+=`/`*=` для immutable/mutable типов (у списков это in-place, у строк — создание нового).
* Поведение `set`/`dict` при коллизиях; как выбирать размер/перехеш.
* Почему `list.remove(x)` — `O(n)`, а `set.discard(x)` — амортиз. `O(1)`.
* Чем `bytes.split` отличается от `str.split` (аргументы — тоже байты vs строки).
* На что влияет «стабильность порядка» словаря в алгоритмах (например, сериализация).

---

Если хочешь, сделаю из этого **тренажёр**: дам тебе 20–30 задач/вопросов «как на собеседовании» (с кодом и подвохами), а потом вместе разберём решения и почему так.
